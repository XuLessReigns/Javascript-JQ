面向对象：
	创建对象的3种方法：
	方法一：工厂式的构建对象
		使用工厂方法构建对象属于js中比较老的一种方式，无法检测实例归属


	方法二：使用字面量构建对象
		优点：书写简单 结构清晰 
		
		缺点：同样无法检测实例归属，
		
		目前是一种比较广泛的构建对象方式

	方法三：使用构造函数构建对象
		
		new操作符：使用new操作符调用一个函数时，该函数会变成构造函数，首先该构造函数的

		内部的this指向会指向自己实例本身（该对象自己） 其次该构造函数返回值会发生改变。
			
		默认情况下（没有return的情况下）：返回一个对象的实例。

		注意：若书写return，则return后面必须为对象（Object类型），若是基本数据还是返回实例本身。		

		缺点：当有多个实例，他们有着相同的属性（或方法），此时内存任然会开辟多个空间存储该属性（或方法），这样会造成内存冗余的问题。

		解决办法：构造对象时，将方法放于该构造函数的原型对象中可以解决该对象创建多个实例造成的内存冗余问题。其解决内存冗余的原理是因为有原型对象中的属性可以被多个实例共享
		
原型对象中的属性可以被多个实例共享		
原型对象存在于构造函数的属性（prototype）中，prototype的值是一个Object类型数据（对象）
构建对象时将方法放于该构造函数的原型对象中，可以解决该对象创建多个实例造成的内存冗余问题	
（原理：原型对象中的属性可以被多个实例共享）


原型链的查找规则：
在访问（调用）一个对象的属性时先从实例本身查找该属性，若能找到则直接使用，若无法找到则向该实例中的
原型对象进行查找，若原型对象中无法找到，则会向原型对象下的原型对象继续查找，直到找到Object
基类的原型中，若还找不到则执行动态创建属性，（此描述的原型对象是指__proto__属性）

当为一个对象中属性赋值时，先从实例本身中查找，实例中存在该属性则覆盖实例中的属性值，如果实例不存在该属性则直接在该实例中创建属性（不会影响到原型中的同名属性）